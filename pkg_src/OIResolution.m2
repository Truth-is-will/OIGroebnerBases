-- Cache for storing OI-resolutions computed with oiRes
oiResCache = new MutableHashTable

-- Define the new Type OIResolution
-- COMMENT: Should be of the form {dd => List, modules => List}
OIResolution = new Type of HashTable
OIResolution.synonym = "OI-resolution"

net OIResolution := C -> (
    n := "0: "|toString C.modules#0;
    for i from 1 to #C.modules - 1 do n = n || toString i | ": "|toString C.modules#i;
    n
)

describe OIResolution := C -> (
    n := "0: "|net C.modules#0;
    for i from 1 to #C.modules - 1 do n = n || toString i | ": "|net C.modules#i;
    n
)

OIResolution _ ZZ := (C, n) -> C.modules#n

-- PURPOSE: Make an OI-resolution from an OI-Groebner basis
-- INPUT: '(L, n)', a List 'L' and an integer 'n'
-- OUTPUT: An OIResolution of length n for the OI-module generated by the elements of L
-- COMMENT: "FastNonminimal => true" will not minimize the resolution (in the graded case)
-- COMMENT: "Verbose => true" will print more information
-- COMMENT: "MinimalOIGB => true" will compute a minimal GB at each step
oiRes = method(TypicalValue => OIResolution, Options => {FastNonminimal => false, Verbose => false, MinimalOIGB => false})
oiRes(List, ZZ) := opts -> (L, n) -> (
    if n < 0 then error "Expected nonnegative integer";
    if #L == 0 then error "Expected nonempty List";

    -- Return the resolution if it already exists
    if oiResCache#?(L, n) then return oiResCache#(L, n);

    ddMut := new MutableList;
    modulesMut := new MutableList;

    -- Make the initial resolution
    freeOIMod := freeOIModuleFromElement L#0;
    e := freeOIMod.basisSym;

    if opts.Verbose then print "Computing an OI-Groebner basis...";
    oigb := oiGB(L, Verbose => opts.Verbose, MinimalOIGB => opts.MinimalOIGB);

    if opts.Verbose then print "Computing syzygies...";
    currentGB := oigb;
    for i to n do (
        syzGens := oiSyz(currentGB, value concatenate(e, toString i), Verbose => opts.Verbose, MinimalOIGB => opts.MinimalOIGB);
        currentGB = syzGens;
        if #syzGens == 0 then (
            modulesMut#i = 0;
            ddMut#i = 0;
            break
        );
        currentFreeOIMod := freeOIModuleFromElement syzGens#0;
        modulesMut#i = currentFreeOIMod;
        ddMut#i = getMonomialOrder currentFreeOIMod
    );

    -- Minimize the resolution
    if #ddMut > 1 then (
        if opts.Verbose then print "Minimizing resolution...";
        done := false;
        -- FINISH THIS
    );

    ret := new OIResolution from {dd => new List from ddMut, modules => new List from modulesMut};

    -- Store the resolution
    oiResCache#(L, n) = ret;

    ret
)