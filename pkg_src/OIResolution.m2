-- Cache for storing OI-resolutions computed with oiRes
oiResCache = new MutableHashTable

-- Define the new Type OIResolution
-- COMMENT: Should be of the form {dd => List, modules => List}
OIResolution = new Type of HashTable

net OIResolution := C -> (
    n := "0: "|toString C.modules#0;
    for i from 1 to #C.modules - 1 do n = n || toString i | ": "|toString C.modules#i;
    n
)

describe OIResolution := C -> (
    n := "0: Module: "|net C.modules#0||"Differential: "|net C.dd#0;
    for i from 1 to #C.modules - 1 do n = n || toString i | ": Module: "|net C.modules#i||"Differential: "|net C.dd#i;
    n
)

OIResolution _ ZZ := (C, n) -> C.modules#n

-- PURPOSE: Make an OI-resolution from an OI-Groebner basis
-- INPUT: '(L, n)', a List 'L' and an integer 'n'
-- OUTPUT: An OIResolution of length n for the OI-module generated by the elements of L
-- COMMENT: "FastNonminimal => true" will not minimize the resolution (in the graded case)
-- COMMENT: "Verbose => true" will print more information
-- COMMENT: "MinimalOIGB => false" will not compute a minimal GB at each step
oiRes = method(TypicalValue => OIResolution, Options => {FastNonminimal => false, Verbose => false, MinimalOIGB => true})
oiRes(List, ZZ) := opts -> (L, n) -> (
    if n < 0 then error "Expected nonnegative integer";
    if #L == 0 then error "Expected nonempty List";

    -- Return the resolution if it already exists
    if oiResCache#?(L, n, opts.FastNonminimal, opts.MinimalOIGB) then return oiResCache#(L, n, opts.FastNonminimal, opts.MinimalOIGB);

    ddMut := new MutableList;
    modulesMut := new MutableList;

    -- Make the initial resolution
    freeOIMod := freeOIModuleFromElement L#0;
    e := freeOIMod.basisSym;

    if opts.Verbose then print "Computing an OI-Groebner basis...";
    oigb := oiGB(L, Verbose => opts.Verbose, MinimalOIGB => opts.MinimalOIGB);

    if opts.Verbose then print "----------------------------------------\n----------------------------------------\nComputing syzygies...";
    currentGB := oigb;
    for i to n do (
        currentSymbol := getSymbol concatenate(e, toString i);
        syzGens := oiSyz(currentGB, currentSymbol, Verbose => opts.Verbose, MinimalOIGB => opts.MinimalOIGB);
        if #syzGens == 0 then (
            shifts := for elt in currentGB list -degree elt;
            widths := for elt in currentGB list widthOfElement elt;
            modulesMut#i = makeFreeOIModule(freeOIMod.polyOIAlg, currentSymbol, widths, DegreeShifts => flatten shifts);
            ddMut#i = makeFreeOIModuleMap(freeOIMod, modulesMut#i, currentGB);

            if n > 0 then (
                currentSymbolPlusOne := getSymbol concatenate(e, toString(i + 1));
                modulesMut#(i + 1) = makeFreeOIModule(freeOIMod.polyOIAlg, currentSymbolPlusOne, {}, DegreeShifts => {}); -- Zero module
                ddMut#(i + 1) = makeFreeOIModuleMap(modulesMut#i, modulesMut#(i + 1), {}) -- Zero map
            );

            break
        );

        currentGB = syzGens;
        currentFreeOIMod0 := freeOIModuleFromElement syzGens#0;
        currentFreeOIMod := makeFreeOIModule(currentFreeOIMod0.polyOIAlg, currentFreeOIMod0.basisSym, currentFreeOIMod0.genWidths, DegreeShifts => currentFreeOIMod0.degShifts);
        oldFomm := getMonomialOrder currentFreeOIMod0;
        newFomm := makeFreeOIModuleMap(target oldFomm, currentFreeOIMod, oldFomm.genImages);
        installSchreyerMonomialOrder newFomm;
        modulesMut#i = currentFreeOIMod;
        ddMut#i = newFomm
    );

    -- Minimize the resolution
    if #ddMut > 1 and not (#ddMut == 2 and isZero ddMut#1) and isHomogeneous ddMut#0 and not opts.FastNonminimal then (
        if opts.Verbose then print "----------------------------------------\n----------------------------------------\nMinimizing resolution...";
        done := false;
        while not done do (
            done = true;

            -- Look for units on identity basis elements
            unitFound := false;
            local data;
            for i from 1 to #ddMut - 1 do (
                ddMap := ddMut#i;
                if isZero ddMap then continue; -- Skip any zero maps
                srcMod := source ddMap;
                targMod := target ddMap;
                for j to #ddMap.genImages - 1 do (
                    if isZero ddMap.genImages#j then continue;
                    oiTerms := getOITermsFromVector(ddMap.genImages#j, Combine => true);
                    for term in oiTerms do (
                        b := term.basisIndex;
                        if b.oiMap.assignment === toList(1..b.oiMap.Width) then
                            if isUnit term.ringElement then (
                                unitFound = true;
                                done = false;
                                data = {i, j, term};
                                if opts.Verbose then print("Unit found on term: "|net term);
                                break
                            );
                        if unitFound then break
                    );
                    if unitFound then break
                );
                if unitFound then break
            );
            
            -- Prune the sequence
            if unitFound then (
                term := data#2;
                targBasisIdx := term.basisIndex.idx - 1; -- Recall idx's start at 1
                srcBasisIdx := data#1;
                ddMap := ddMut#(data#0);
                srcMod := source ddMap;
                targMod := target ddMap;

                if opts.Verbose then print "Pruning...";

                -- Compute the new modules
                newSrcMod := makeFreeOIModule(srcMod.polyOIAlg, srcMod.basisSym, remove(srcMod.genWidths, srcBasisIdx), DegreeShifts => remove(srcMod.degShifts, srcBasisIdx));
                newTargMod := makeFreeOIModule(targMod.polyOIAlg, targMod.basisSym, remove(targMod.genWidths, targBasisIdx), DegreeShifts => remove(targMod.degShifts, targBasisIdx));
                
                -- Compute the new differential
                newGenImages := new MutableList;
                if not (isZero newSrcMod or isZero newTargMod) then (
                    k := 0;
                    targBasisOIMap := makeOIMap(targMod.genWidths#targBasisIdx, toList(1..targMod.genWidths#targBasisIdx));
                    srcBasisOIMap := makeOIMap(srcMod.genWidths#srcBasisIdx, toList(1..srcMod.genWidths#srcBasisIdx));
                    for i to #srcMod.genWidths - 1 do (
                        if i == srcBasisIdx then continue;
                        oiTerms := getOITermsFromVector(ddMap.genImages#i, Combine => true);
                        stuff := 0_(getFreeModuleInWidth(srcMod, srcMod.genWidths#i));
                        oiMaps := getOIMaps(targMod.genWidths#targBasisIdx, srcMod.genWidths#i);

                        -- Calculate the stuff to subtract off
                        if #oiMaps > 0 and #oiTerms > 0 then
                            for term in oiTerms do (
                                b := term.basisIndex;
                                if not b.idx == targBasisIdx + 1 then continue;
                                if not b.oiMap.Width == srcMod.genWidths#i then continue;

                                local oiMap;
                                for oimap in oiMaps do
                                    if b.oiMap === composeOIMaps(oimap, targBasisOIMap) then (oiMap = oimap; break);
                                                                
                                modMap := getInducedModuleMap(srcMod, oiMap);
                                basisElt := getVectorFromOITerms {makeBasisElement makeBasisIndex(srcMod, srcBasisOIMap, srcBasisIdx + 1)};
                                stuff = stuff + term.ringElement * modMap basisElt
                            );

                        -- Calculate the new image
                        basisElt := getVectorFromOITerms {makeBasisElement makeBasisIndex(srcMod, makeOIMap(srcMod.genWidths#i, toList(1..srcMod.genWidths#i)), i + 1)};
                        field := srcMod.polyOIAlg.baseField;
                        newGenImage0 := ddMap(basisElt - lift(1 // term.ringElement, field) * stuff);
                        newOITerms := getOITermsFromVector(newGenImage0, Combine => true);
                        newGenImage := 0_(getFreeModuleInWidth(newTargMod, widthOfElement newGenImage0));
                        if not isZero newGenImage0 then
                            for newTerm in newOITerms do (
                                idx := newTerm.basisIndex.idx;
                                if idx > targBasisIdx + 1 then idx = idx - 1;
                                newGenImage = newGenImage + getVectorFromOITerms {makeOITerm(newTerm.ringElement, makeBasisIndex(newTargMod, newTerm.basisIndex.oiMap, idx))}
                            );

                        newGenImages#k = newGenImage;
                        k = k + 1
                    )
                );

                ddMut#(data#0) = makeFreeOIModuleMap(newTargMod, newSrcMod, new List from newGenImages);
                modulesMut#(data#0) = newSrcMod;
                modulesMut#(data#0 - 1) = newTargMod;

                -- Adjust the adjacent differentials
                -- Below map
                ddMap = ddMut#(data#0 - 1);
                ddMut#(data#0 - 1) = makeFreeOIModuleMap(target ddMap, newTargMod, remove(ddMap.genImages, targBasisIdx)); -- Restriction

                -- Above map
                if data#0 < #ddMut - 1 then (
                    newGenImages = new MutableList;
                    ddMap = ddMut#(1 + data#0);
                    srcMod = source ddMap;
                    targMod = target ddMap;

                    if not (isZero srcMod or isZero targMod) then (
                        for i to #ddMap.genImages - 1 do (
                            oiTerms := getOITermsFromVector ddMap.genImages#i;
                            newTerms := new MutableList;
                            k := 0;
                            for term in oiTerms do (
                                idx := term.basisIndex.idx;
                                if idx == srcBasisIdx + 1 then continue; -- Projection
                                if idx > srcBasisIdx + 1 then idx = idx - 1; -- Relabel
                                newTerms#k = makeOITerm(term.ringElement, makeBasisIndex(newSrcMod, term.basisIndex.oiMap, idx));
                                k = k + 1;
                            );
                            
                            if isZero ddMap.genImages#i then newGenImages#i = ddMap.genImages#i else newGenImages#i = getVectorFromOITerms new List from newTerms
                        )
                    );

                    srcMod.monOrder#0 = Lex;
                    ddMut#(1 + data#0) = makeFreeOIModuleMap(newSrcMod, srcMod, new List from newGenImages)
                )
            )
        )
    );

    ret := new OIResolution from {dd => new List from ddMut, modules => new List from modulesMut};

    -- Store the resolution
    oiResCache#(L, n, opts.FastNonminimal, opts.MinimalOIGB) = ret;

    ret
)

-- PURPOSE: Verify that an OIResolution is a complex
-- INPUT: An OIResolution 'C'
-- OUTPUT: true if C is a complex, false otherwise
isComplex = method(TypicalValue => Boolean)
isComplex OIResolution := C -> (
    if #C.dd < 2 then error "Expected a sequence with at least 2 maps";

    -- Check if the maps compose to zero
    for i from 1 to #C.dd - 1 do (
        modMap0 := C.dd#(i - 1);
        modMap1 := C.dd#i;
        if isZero modMap0 or isZero modMap1 then continue;
        srcMod := source modMap1;
        basisElts := for i to #srcMod.genWidths - 1 list makeBasisElement makeBasisIndex(srcMod, makeOIMap(srcMod.genWidths#i, toList(1..srcMod.genWidths#i)), i + 1);
        for basisElt in basisElts do (
            result := modMap0 modMap1 getVectorFromOITerms {basisElt};
            if not isZero result then return false
        )
    );

    true
)